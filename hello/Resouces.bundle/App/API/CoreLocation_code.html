
<!doctype html>
<html>
    <head>
        <meta charset='UTF-8'>
        <meta name="viewport" content=" width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"> 
        <link type="text/css" rel="stylesheet" href="../static/github.min.css" />
        <script src="../static/marked.min.js"></script>
        <script src="../static/highlight.min.js"></script>
        <style>body{font-size: 16px;line-height: 21px;-webkit-text-size-adjust: none;}</style>
    </head>
    <body>
        <div id="content"></div>
        <script>
let mdtext = `
\`\`\`swift
import SwiftUI
import CoreLocation

class LocationModel: NSObject {

    @objc var coordinate: CLLocationCoordinate2D = CLLocationCoordinate2DMake(0, 0)
    @objc var adcode: String?
    @objc var citycode: String?
    @objc var country: String?
    @objc var city: String?
    @objc var area: String?
    @objc var province: String?
    @objc var address: String?
    @objc var street: String?
}


class EPLocationManager: NSObject {
    
    @objc public static let manager: EPLocationManager = { EPLocationManager() }()
    
    private lazy var locationManager = CLLocationManager()
    private var locationCompletionBlock: ((LocationModel) -> ())?
    
    @objc public var userLocationModel: LocationModel?
    private var isAloneLocaion: Bool=false

    private override init() {
        super.init()
        configLocationManager()
    }

    deinit {
        locationManager.delegate = nil
    }

    private func configLocationManager() {
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = kCLDistanceFilterNone
        locationManager.pausesLocationUpdatesAutomatically = false
        locationManager.requestWhenInUseAuthorization()
    }

     // 停止定位
    func stopLocation() {
        locationManager.stopUpdatingLocation()
    }

     // 单次定位
    @objc func aloneReGeocodeLocation(_ completionBlock: ((LocationModel) -> ())?=nil) {
        isAloneLocaion = true
        serialReGeocodeLocation(completionBlock)
    }

    // 连续定位
    func serialReGeocodeLocation(_ completionBlock: ((LocationModel) -> ())?=nil) {
        self.locationCompletionBlock = completionBlock
        locationManager.stopUpdatingLocation()
        locationManager.startUpdatingLocation()
        locationManager.startUpdatingHeading()
    }
}


extension EPLocationManager: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {

        for location in locations {
            if location.coordinate.latitude > 0 && location.coordinate.longitude > 0 {
                if isAloneLocaion {
                    stopLocation()
                }
            }
            
            let geocoder = CLGeocoder()
            geocoder.reverseGeocodeLocation(location) { (placemarksArray, error) in
                if error != nil {
                    print("geocoder fail \(error!.localizedDescription)")
                }
                guard let placemarks = placemarksArray else { return }
               
                if placemarks.count > 0 {
                    let placemark = placemarks[0]
                    
                    let model = LocationModel()
                    model.coordinate = location.coordinate
                    
                    model.city = placemark.locality ?? ""
                    model.province = placemark.administrativeArea ?? ""
                    model.area = placemark.subLocality ?? ""
                    model.address = placemark.name ?? ""
                    model.street = placemark.thoroughfare ?? ""

                    self.userLocationModel = model
                    self.locationCompletionBlock?(model)
                }
            }
        }
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("location is fail \(error.localizedDescription)")
    }
}

struct PrimaryBtnStyle: ButtonStyle {
    @State var bgColor = Color.blue
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .frame(height: 50)
            .frame(maxWidth: .infinity)
            .background(bgColor)
            .foregroundColor(.white)
            .cornerRadius(10)
            .scaleEffect(configuration.isPressed ? 0.9 : 1.0)
    }
}

struct api_CoreLocation: View {
    @State var LocationPermissionNoteEnabled: Bool = false
    
    @State var LocationCity: String = ""
    @State var LocationArea: String = ""
    @State var address: String = ""
    @State var street: String = ""
    @State var LatitudeLongitude = LocationModel().coordinate
    
    var body: some View {
        VStack {
            VStack(alignment: .leading, spacing: 10) {
                Text("当前城市: \(LocationCity)")
                    .font(.body)
                Text("当前地区: \(LocationArea)")
                    .font(.body)
                Text("当前街道: \(street)")
                    .font(.body)
                Text("经纬度: \(LatitudeLongitude.latitude) \(LatitudeLongitude.longitude)")
                    .font(.body)
            }
            .offset(y: -30)
            
            Button(action: {
                startLocation()
            }, label: {
                Label("获取定位", systemImage: "location.fill")
            })
            .buttonStyle(PrimaryBtnStyle())
            .alert("定位权限未开启", isPresented: $LocationPermissionNoteEnabled) {
                Button("我知道了") {}
                Button("前往设置") {
                    openiPhoneSetting()
                }
            }
            
            Button(action: {
                EPLocationManager.manager.stopLocation()
            }, label: {
                Label("停止定位", systemImage: "stop.circle")
            })
            .buttonStyle(PrimaryBtnStyle())
            
        }
        .padding()
        .navigationTitle("Core Location")
    }
    
    // 检查定位权限
    func checkLocationPermission() -> Bool {
        let authStatus = CLLocationManager.authorizationStatus()
        return authStatus != .restricted && authStatus != .denied
    }
    
    // 开始定位
    func startLocation() {
        let checkResult = checkLocationPermission()
        if checkResult {
            EPLocationManager.manager.aloneReGeocodeLocation { (model) in
                LocationArea = model.area ?? ""
                LocationCity = model.city ?? ""
                LatitudeLongitude = model.coordinate
                address = model.address ?? ""
                street = model.street ?? ""
            }
        } else {
            self.LocationPermissionNoteEnabled.toggle()
        }
    }
    
    // 打开iPhone手机系统设置
    func openiPhoneSetting() {
        if #available(iOS 10, *) {
            if let url = URL(string: UIApplication.openSettingsURLString) {
                UIApplication.shared.open(url)
            }
        } else {
            if let appSettings = NSURL(string: UIApplication.openSettingsURLString) {
                UIApplication.shared.openURL(appSettings as URL)
            }
        }
    }
}

struct api_CoreLocation_Previews: PreviewProvider {
    static var previews: some View {
        api_CoreLocation()
    }
}

\`\`\`
`
            hljs.highlightAll();
            document.getElementById('content').innerHTML = marked.parse(mdtext);
        </script>
    </body>
</html>
